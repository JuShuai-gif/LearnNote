# 旋转矩阵  
### 一、二维旋转
![image](https://img-blog.csdnimg.cn/20200328104652932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDY1NTA5,size_16,color_FFFFFF,t_70/resize,p_80)    

记为 

![image](https://img-blog.csdnimg.cn/20200328104747524.png)  
  
#### 绕任一点旋转 

**思路**：先将旋转点移动到原点，然后进行旋转，然后复原。具体步骤如下：  
1. 首先将旋转点移动到原点
2. 执行绕原点操作
3. 再将图形移回原来的位置    

 ![image](https://s2.loli.net/2022/01/09/K46IhlBiMCwxqRP.png) 
   
 矩阵形式：  
$$
M=
\begin{bmatrix}
1 & 0 & tx\\
0 & 1 & ty\\
0 & 0 & 1\\
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta & -\sin \theta & 0\\
\sin\theta & \cos \theta & 0\\
0 & 0 & 1\\
\end{bmatrix}
*
\begin{bmatrix}
1 & 0 & -tx\\
0 & 1 & -ty\\
0 & 0 & 1\\
\end{bmatrix}
$$


### 二、三维旋转  

绕x和z旋转的变换矩阵  

![image](https://img-blog.csdnimg.cn/20200328111037655.png)  

(绕z轴，故z不变，且x转向y)  

![image](https://img-blog.csdnimg.cn/20200328111131496.png)  

(绕x轴，故x不变，且y转向z)  

绕y轴会有一点不同，但只要记住需要z转向x，很快便能反应过来!    

![image](https://img-blog.csdnimg.cn/20200328111305835.png)  
  

# 轴角旋转  

**这种方法有两种实现方式**  

### 1.坐标轴对齐  

**可以分为两种情况，一种是平行于坐标轴的，一种是不平行于坐标轴的 两种方法不过是第一步不一样，不平行于坐标轴的需要先进行一步位移操作**  
- 将旋转轴平移至与坐标轴重合，对应平移操作$T$  
- 旋转，对应操作$R$  
- 步骤1的逆操作，对应操作$T^{-1}$  
  

![image](https://img-blog.csdn.net/20170324230357975?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3N4aWFvc2h1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  

绕轴 $U ( a,b,c ) $（与轴的长度无关，计算前先将轴单位化化为单位向量，即 $a^{2}+b^{2}+c^{2}=1$ ）旋转 $\theta$ 角度公式。  

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111103133.png)

首先我们将 $U$ 看待为其由 Z 轴，绕y轴旋转了$\alpha$，又绕 X 轴旋转了$-\beta$（逆时针是正，顺时针是负）。如果我们要求一个向量绕 $U$ 旋转 $\theta$ 的公式，我们可以先执行将 U 旋转到 Z 轴的变换 $R$ ，而后执行绕 Z 轴旋转$\theta$，之后再执行$R^{-1}$将 Z 轴再移回 U 。由于有点绕，我们再分步骤详述一下：

1. 将旋转轴 U 绕 X 轴旋转 $\beta$ 转至 XoZ 平面

2. 将步骤1的成果绕 Y 轴旋转 $-\alpha$ 转至与 Z 轴重合

3. 绕 Z 轴旋转 $\theta$

4. 执行步骤2的逆过程

5. 执行步骤1的逆过程

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/E629B753DF55D834186C6CA97C459BEE.png)

#### 步骤 1
将向量 $U$ 绕X轴旋转 $\beta$ (这时旋转是顺时针故是正的)，$\beta$ 其实在 YoZ 面中$\beta$根据三角形勾股定理可以求出来，然后就可以用矩阵表示，绕 X 轴 旋转即可  ($V$向量其实是向量$U$投影到 YoZ 面上的)

角度：
$$
\cos\beta=
\dfrac{c}{\sqrt{\smash[b]{b^2+c^2}}}
$$
$$
\sin\beta=
\dfrac{b}{\sqrt{\smash[b]{b^2+c^2}}}
$$
绕X轴顺时针旋转 ：

$$
R_{x}(\beta)=\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\beta & -\sin\beta & 0\\
0 & \sin\beta & \cos\beta & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

带入上面计算的角度之后，变成了下式

$$
R_{x}(\beta)=\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \dfrac{c}{\sqrt{\smash[b]{b^2+c^2}}} & -\dfrac{b}{\sqrt{\smash[b]{b^2+c^2}}} & 0\\
0 & \dfrac{b}{\sqrt{\smash[b]{b^2+c^2}}} & \dfrac{c}{\sqrt{\smash[b]{b^2+c^2}}} & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

#### 步骤 2
现在向量 $U$ 已经 成了 $W$ ,这一步就是绕Y轴逆时针旋转，也就是说 $\alpha$ 是负的

角度： 
$$
\cos\alpha=
\dfrac{\sqrt{\smash[b]{b^2+c^2}}}{\sqrt{\smash[b]{a^2+b^2+c^2}}}
$$
$$
\sin\alpha=
\dfrac{a}{\sqrt{\smash[b]{a^2+b^2+c^2}}}
$$

绕 Y 逆时针旋转矩阵形式为：

$$
R_{Y}(-\alpha)=\begin{bmatrix}
\cos\alpha & 0 & -\sin\alpha & 0 \\
0 & 1 & 0 & 0\\
\sin\alpha & 0 & \cos\alpha & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

带入角度为下式：  

$$
R_{Y}(-\alpha)=\begin{bmatrix}
\dfrac{\sqrt{\smash[b]{b^2+c^2}}}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 & -\dfrac{a}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 \\
0 & 1 & 0 & 0\\
\dfrac{a}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 & \dfrac{\sqrt{\smash[b]{b^2+c^2}}}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

在完成前面两个步骤之后，$U$方向和$Z$轴完全重合，因此执行旋转 θ 角，执行的是一次绕z轴的基本三维旋转（记作 R(θ)，根据之前的讨论，我们可以得到：
$$
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\
\sin\theta & \cos\theta & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

最后两步骤是前面1和2的逆操作，也就是绕 $Y$轴旋转 $β$ 和绕$X$轴旋转 $−α$，这两个矩阵分别记作 $Ry(β)$ 和 $Rx(−α)$，得到它们的方式很简单，只需要将上面步骤1和步骤2中的角度修改成相反数即可，也就是：(**其实也就是逆矩阵，就是转置**)

$$
R_{x}(-\beta)=\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \dfrac{c}{\sqrt{\smash[b]{b^2+c^2}}} & \dfrac{b}{\sqrt{\smash[b]{b^2+c^2}}} & 0\\
0 & -\dfrac{b}{\sqrt{\smash[b]{b^2+c^2}}} & \dfrac{c}{\sqrt{\smash[b]{b^2+c^2}}} & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$

$$
R_{Y}(\alpha)=\begin{bmatrix}
\dfrac{\sqrt{\smash[b]{b^2+c^2}}}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 & \dfrac{a}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 \\
0 & 1 & 0 & 0\\
-\dfrac{a}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0 & \dfrac{\sqrt{\smash[b]{b^2+c^2}}}{\sqrt{\smash[b]{a^2+b^2+c^2}}} & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
$$
最终得到 绕任意轴u旋转的旋转矩阵是【因为使用的列向量，因此执行的是左乘（从右往左）】：
$$
M_{R}=R_{y}(\beta)R_{x}(-\alpha)R_{z}(\theta)R_{y}(-\beta)R_{x}(\alpha)
$$

由于$a^2+b^2+c^2=1$所以上式可以化简成为下图：

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111140725.png)

代码如下：
```
void RotateArbitraryAxis(D3DXMATRIX* pOut, D3DXVECTOR3* axis, float theta)
{
    D3DXVec3Normalize(axis, axis);
    float u = axis->x;
    float v = axis->y;
    float w = axis->z;

    pOut->m[0][0] = cosf(theta) + (u * u) * (1 - cosf(theta));
    pOut->m[0][1] = u * v * (1 - cosf(theta)) + w * sinf(theta);
    pOut->m[0][2] = u * w * (1 - cosf(theta)) - v * sinf(theta);
    pOut->m[0][3] = 0;

    pOut->m[1][0] = u * v * (1 - cosf(theta)) - w * sinf(theta);
    pOut->m[1][1] = cosf(theta) + v * v * (1 - cosf(theta));
    pOut->m[1][2] = w * v * (1 - cosf(theta)) + u * sinf(theta);
    pOut->m[1][3] = 0;

    pOut->m[2][0] = u * w * (1 - cosf(theta)) + v * sinf(theta);
    pOut->m[2][1] = v * w * (1 - cosf(theta)) - u * sinf(theta);
    pOut->m[2][2] = cosf(theta) + w * w * (1 - cosf(theta));
    pOut->m[2][3] = 0;

    pOut->m[3][0] = 0;
    pOut->m[3][1] = 0;
    pOut->m[3][2] = 0;
    pOut->m[3][3] = 1;
```
**如果旋转轴是不过原点的，那么第一步和最后一步就不能省略，将所有七个矩阵连乘起来，得到如下变换矩阵**

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111141452.png)

对应如下这个超长的矩阵，在这里(u, v, w) = (a2, b2, c2) - (a1, b1, c1)，且是单位向量，a, b, c分别表示(a1, b1, c1)

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111141521.png)

将上面的过程写成函数，该函数接受四个参数，第一个参数是一个输出参数，用来保存得到的旋转矩阵，第二个和第三个参数是旋转轴的两个端点，最后一个参数是旋转角度θ，注意，在函数中我们已经将上面的矩阵转置了，因为上面是按照列向量计算的。

```
void RotateArbitraryLine(D3DXMATRIX* pOut, D3DXVECTOR3* v1, D3DXVECTOR3* v2, float theta)
{
    float a = v1->x;
    float b = v1->y;
    float c = v1->z;

    D3DXVECTOR3 p = *v2 - *v1;
    D3DXVec3Normalize(&p, &p);
    float u = p.x;
    float v = p.y;
    float w = p.z;

    float uu = u * u;
    float uv = u * v;
    float uw = u * w;
    float vv = v * v;
    float vw = v * w;
    float ww = w * w;
    float au = a * u;
    float av = a * v;
    float aw = a * w;
    float bu = b * u;
    float bv = b * v;
    float bw = b * w;
    float cu = c * u;
    float cv = c * v;
    float cw = c * w;

    float costheta = cosf(theta);
    float sintheta = sinf(theta);

    pOut->m[0][0] = uu + (vv + ww) * costheta;
    pOut->m[0][1] = uv * (1 - costheta) + w * sintheta;
    pOut->m[0][2] = uw * (1 - costheta) - v * sintheta;
    pOut->m[0][3] = 0;

    pOut->m[1][0] = uv * (1 - costheta) - w * sintheta;
    pOut->m[1][1] = vv + (uu + ww) * costheta;
    pOut->m[1][2] = vw * (1 - costheta) + u * sintheta;
    pOut->m[1][3] = 0;

    pOut->m[2][0] = uw * (1 - costheta) + v * sintheta;
    pOut->m[2][1] = vw * (1 - costheta) - u * sintheta;
    pOut->m[2][2] = ww + (uu + vv) * costheta;
    pOut->m[2][3] = 0;

    pOut->m[3][0] = (a * (vv + ww) - u * (bv + cw)) * (1 - costheta) + (bw - cv) * sintheta;
    pOut->m[3][1] = (b * (uu + ww) - v * (au + cw)) * (1 - costheta) + (cu - aw) * sintheta;
    pOut->m[3][2] = (c * (uu + vv) - w * (au + bv)) * (1 - costheta) + (av - bu) * sintheta;
    pOut->m[3][3] = 1;
}
```

[参考博客1](https://blog.csdn.net/csxiaoshui/article/details/65446125)

[参考博客2](https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html)

[参考博客3](https://www.cnblogs.com/meteoric_cry/p/7987548.html)

### 2.向量分解  
详见
[3D数学基础P91](http://124.223.24.112:8083/book/55)
# 欧拉角

旋转是一个过程，一个物体围绕周或者点角度变化的过程。为了描述这个过程我们必须有参照物，于是我们先定义一个世界坐标系，笛卡尔坐标系。

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111145838.png)

欧拉角用（x, y, z) 分别来表示这个物体相对三个坐标系的夹角，这是由数学家欧拉首先提出而得名的。

![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111145907.png)

然而仅仅有（x, y, z) 来表示旋转是不够的，还有两个因素：

首先是旋转顺序，从各个轴上进行角度旋转时xyz先后的不同会得到不同的结果。我们称这个顺序定义为顺规，下面一段是维基百科的定义：

在经典力学里，时常用zxz顺规来设定欧拉角；照着第二个转动轴的轴名，简称为x顺规。另外，还有别的欧拉角组。合法的欧拉角组中，唯一的限制是，任何两个连续的旋转，必须绕着不同的转动轴旋转。因此，一共有12种顺规。例如，y顺规，第二个转动轴是y-轴，时常用在量子力学、核子物理学、粒子物理学。另外，还有一种顺规，xyz顺规，是用在航空航天工程学；

按(z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y)轴序列旋转，即第一个旋转轴和最后一个旋转轴相同，我们称之为经典欧拉角（Proper Euler Angle）。

按(x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z)轴序列旋转，即三个不同的轴，我们称之为泰特布莱恩角（Tait–Bryan angles）。

其次是旋转的参照坐标系，欧拉角按旋转的坐标系分为：

内旋（intrinsic rotation）即按照物体本身的坐标系进行旋转，坐标系会跟随旋转与世界坐标系产生偏移。

外旋（extrinsic rotation）即根据世界坐标系进行旋转。


这是我们看看Unity3d中Transform的Rotate，最后一个参数即坐标系：

```
public void Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);
```
注意：Unity3d使用的是zxy的顺规，且进行一次欧拉旋转的zxy依次执行过程中，相对轴始终是运算开始之前的轴向。
## 万向节死锁
### Pitch、Yaw、Roll
在飞行器的航行中，进行XYZ三个方向旋转的旋转有专业的术语：
![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111150253.png)

沿着机身右方轴（Unity中的+X）进行旋转，称为**pitch**，中文叫**俯仰**。
沿着机头上方轴（Unity中的+Y）进行旋转，称为**Yaw**，中文叫**偏航**。
沿着机头前方轴（Unity中的+Z）进行旋转，称为**Roll**，中文叫**桶滚**。

### 数学意义
![](https://gitee.com/JuShuai-gif/blog-image/raw/master/20220111150620.png)

[参考博客1](https://blog.csdn.net/csxiaoshui/article/details/65437633)

[参考博客2](https://blog.csdn.net/ccnt_2012/article/details/81327448)

[参考博客3](https://www.matongxue.com/madocs/442)

[参考博客4](https://www.guyuehome.com/33200)

[参考博客5](https://www.zhoulujun.cn/html/theory/Mathematics/Geometry/8149.html)

[参考博客6](https://www.guyuehome.com/33200)
# 四元数
[知乎博客1](https://zhuanlan.zhihu.com/p/27541307)


# 三维旋转：欧拉角、四元数、旋转矩阵、轴角之间的转换
[知乎博客1](https://zhuanlan.zhihu.com/p/45404840)




